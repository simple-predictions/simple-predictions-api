/*
 * raygun
 * https://github.com/MindscapeHQ/raygun4node
 *
 * Copyright (c) 2015 MindscapeHQ
 * Licensed under the MIT license.
 */
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("./types");
var raygun_batch_1 = require("./raygun.batch");
var raygun_messageBuilder_1 = require("./raygun.messageBuilder");
var raygun_offline_1 = require("./raygun.offline");
var timer_1 = require("./timer");
var raygunTransport = __importStar(require("./raygun.transport"));
var debug = require("debug")("raygun");
var DEFAULT_BATCH_FREQUENCY = 1000; // ms
function emptyCallback() { }
var Raygun = /** @class */ (function () {
    function Raygun() {
        this._filters = [];
        this._version = "";
        this._batch = false;
    }
    Raygun.prototype.init = function (options) {
        this._apiKey = options.apiKey;
        this._filters = options.filters || [];
        this._host = options.host;
        this._port = options.port;
        this._useSSL = options.useSSL !== false;
        this._onBeforeSend = options.onBeforeSend;
        this._isOffline = options.isOffline;
        this._groupingKey = options.groupingKey;
        this._tags = options.tags;
        this._useHumanStringForObject =
            options.useHumanStringForObject === undefined
                ? true
                : options.useHumanStringForObject;
        this._reportColumnNumbers = options.reportColumnNumbers;
        this._innerErrorFieldName = options.innerErrorFieldName || "cause"; // VError function to retrieve inner error;
        debug("client initialized");
        if (options.batch && this._apiKey) {
            var frequency = options.batchFrequency || DEFAULT_BATCH_FREQUENCY;
            this._batch = options.batch;
            this._batchTransport = new raygun_batch_1.RaygunBatchTransport({
                interval: frequency,
                httpOptions: {
                    host: this._host,
                    port: this._port,
                    useSSL: !!this._useSSL,
                    apiKey: this._apiKey,
                }
            });
            this._batchTransport.startProcessing();
        }
        this.expressHandler = this.expressHandler.bind(this);
        this.send = this.send.bind(this);
        this._offlineStorage = options.offlineStorage || new raygun_offline_1.OfflineStorage(this.transport());
        this._offlineStorageOptions = options.offlineStorageOptions;
        if (this._isOffline) {
            this._offlineStorage.init(this._offlineStorageOptions);
        }
        return this;
    };
    Raygun.prototype.user = function (req) {
        return null;
    };
    // This function is deprecated, is provided for legacy apps and will be
    // removed in 1.0: use raygun.user instead
    Raygun.prototype.setUser = function (user) {
        this._user = user;
        return this;
    };
    Raygun.prototype.expressCustomData = function (error, request) {
        return {};
    };
    Raygun.prototype.setVersion = function (version) {
        this._version = version;
        return this;
    };
    Raygun.prototype.onBeforeSend = function (onBeforeSend) {
        this._onBeforeSend = onBeforeSend;
        return this;
    };
    Raygun.prototype.groupingKey = function (groupingKey) {
        this._groupingKey = groupingKey;
        return this;
    };
    Raygun.prototype.offline = function () {
        this.offlineStorage().init(this._offlineStorageOptions);
        this._isOffline = true;
    };
    Raygun.prototype.online = function (callback) {
        this._isOffline = false;
        this.offlineStorage().send(callback || emptyCallback);
    };
    Raygun.prototype.setTags = function (tags) {
        this._tags = tags;
    };
    Raygun.prototype.transport = function () {
        if (this._batch && this._batchTransport) {
            return this._batchTransport;
        }
        var client = this;
        return {
            send: function (message, callback) {
                var apiKey = client._apiKey;
                if (!apiKey) {
                    console.error("Encountered an error sending an error to Raygun. No API key is configured, please ensure .init is called with api key. See docs for more info.");
                    return message;
                }
                debug("sending message to raygun (" + message.length + " bytes)");
                function wrappedCallback(error, response) {
                    var durationInMs = stopTimer();
                    if (error) {
                        debug("error sending message (duration=" + durationInMs + "ms): " + error);
                    }
                    else {
                        debug("successfully sent message (duration=" + durationInMs + "ms)");
                    }
                    if (!callback) {
                        return;
                    }
                    return types_1.callVariadicCallback(callback, error, response);
                }
                var stopTimer = timer_1.startTimer();
                return raygunTransport.send({
                    message: message,
                    callback: wrappedCallback,
                    batch: false,
                    http: {
                        host: client._host,
                        port: client._port,
                        useSSL: !!client._useSSL,
                        apiKey: apiKey,
                    },
                });
            },
        };
    };
    Raygun.prototype.send = function (exception, customData, callback, request, tags) {
        var mergedTags = [];
        if (this._tags) {
            mergedTags = mergedTags.concat(this._tags);
        }
        if (tags) {
            mergedTags = mergedTags.concat(tags);
        }
        var builder = new raygun_messageBuilder_1.RaygunMessageBuilder({
            filters: this._filters,
            useHumanStringForObject: this._useHumanStringForObject,
            reportColumnNumbers: this._reportColumnNumbers,
            innerErrorFieldName: this._innerErrorFieldName,
        })
            .setErrorDetails(exception)
            .setRequestDetails(request)
            .setMachineName()
            .setEnvironmentDetails()
            .setUserCustomData(customData)
            .setUser((request && this.user(request)) || this._user)
            .setVersion(this._version)
            .setTags(mergedTags);
        var message = builder.build();
        if (this._groupingKey) {
            message.details.groupingKey =
                typeof this._groupingKey === "function"
                    ? this._groupingKey(message, exception, customData, request, tags)
                    : null;
        }
        if (this._onBeforeSend) {
            message =
                typeof this._onBeforeSend === "function"
                    ? this._onBeforeSend(message, exception, customData, request, tags)
                    : message;
        }
        if (this._isOffline) {
            this.offlineStorage().save(JSON.stringify(message), callback || emptyCallback);
        }
        else {
            this.transport().send(JSON.stringify(message), callback);
        }
        return message;
    };
    Raygun.prototype.expressHandler = function (err, req, res, next) {
        var customData;
        if (typeof this.expressCustomData === "function") {
            customData = this.expressCustomData(err, req);
        }
        else {
            customData = this.expressCustomData;
        }
        this.send(err, customData || {}, function () { }, req, [
            "UnhandledException",
        ]);
        next();
    };
    Raygun.prototype.stop = function () {
        if (this._batchTransport) {
            debug("batch transport stopped");
            this._batchTransport.stopProcessing();
        }
    };
    Raygun.prototype.offlineStorage = function () {
        var storage = this._offlineStorage;
        if (storage) {
            return storage;
        }
        storage = this._offlineStorage = new raygun_offline_1.OfflineStorage(this.transport());
        return storage;
    };
    return Raygun;
}());
exports.Client = Raygun;
exports.default = { Client: exports.Client };
